# Project management tool.

import argparse
from typing import Any
from os import PathLike
import colorama
import datetime
from src import yelets
import os
import multiprocessing
from pathlib import Path
import re
import shutil
import subprocess
import sys
import threading
import time
from typing import Callable, Literal
from pydantic import BaseModel as struct
import configparser

VERSION = 0

INDENTATION = " " * 4

RED = '\033[31m'
GREEN = '\033[32m'
RESET = '\033[0m'
GREY = '\033[90m'
# ]]]] nvim fix

# Project is always called in the current working directory. @todo add ability to override cwd via CLI.
cwd = Path.cwd()
build_dir = Path(cwd, "build")
build_version = 0
build_time = 0
build_debug = False

class Project(struct):
    source: Path
    name: str
    context: dict[str, Any]

current_project: Project
projects: dict[str, Project] = {}

def yelets_call(command: str, callback: Callable[[int, str], None] | None = None) -> int:
    # Always call relatively to current project.
    location = current_project.source

    # Use nushell command.
    if "\"" in command:
        print(f"{colorama.Fore.YELLOW}WARNING{colorama.Fore.RESET}: Please, do not use double-quotes for 'call' commands - they will be replaced with single-quotes. Occurred for project '{current_project.name}', command: {command}")
        command = command.replace("\"", "'")
    command = f"nu -c \"{command}\""

    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=location,
        bufsize=1,
        universal_newlines=True,
    )
    # @todo Make it parallel, somehow. For now it is printed only at the end of the subprocess. At least this behaviour is noticed at Windows.
    if callback is not None:
        if process.stdout is not None:
            for line in process.stdout:
                callback(1, line)
        if process.stderr is not None:
            for line in process.stderr:
                callback(2, line)
    return process.wait()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-cwd", type=Path, dest="cwd", default=Path.cwd())
    subparsers = parser.add_subparsers(title="Commands", dest="command")

    build_parser = subparsers.add_parser("build", help="Build tool.")
    build_parser.add_argument("build_version", type=int)
    build_parser.add_argument("-debug", action="store_true", dest="build_debug")

    args = parser.parse_args()
    global cwd
    cwd = args.cwd

    if args.command == "build":
        build(args)
    else:
        parser.print_help()

def yelets_build_info(target: PathLike):
    print(f"Generate build info to '{target}'.")
    target = Path(target)
    extension = target.suffix.removeprefix(".")
    auto_message = "AUTO-GENERATED BY THE BUILD SYSTEM. DO NOT EDIT!"
    content = ""
    if extension == "py":
        content = f"# {auto_message}\nBUILD_VERSION = {build_version}\nBUILD_TIME = {build_time}\nBUILD_DEBUG = {'True' if build_debug else 'False'}"
    elif extension == "js":
        BRACKET_LEFT = "{"
        BRACKET_RIGHT = "}"
        content = f"// {auto_message}\nconst BUILD_VERSION = {build_version};\nconst BUILD_TIME = {build_time};\nconst BUILD_DEBUG = {'true' if build_debug else 'false'};\nexport {BRACKET_LEFT} BUILD_VERSION, BUILD_TIME, BUILD_DEBUG {BRACKET_RIGHT};\n"
    else:
        panic(f"Unsupported build info extension '{extension}' at location '{config_path}'.")
    with target.open("w+") as f:
        f.write(content)

def panic(message: str):
    raise Exception("PANIC: " + message)

def yelets_build_include(target: PathLike, dest: PathLike | None = None):
    target = Path(target)
    print(f"build: Include target '{target}'." + f"Destination is altered to '{dest}'." if dest else "") 
    project_build_dir = Path(build_dir, current_project.name)
    # Project build might already exist - due to multiple includes or other commands.
    project_build_dir.mkdir(parents=True, exist_ok=True)

    include_parts = (target, dest)
    from_ = target
    to_ = target
    if ".." in str(target):
        panic(f"The '..' paths found in include '{target}'.")
    elif len(include_parts) > 2:
        panic(f"Incorrect include schematics '{target}'.")
    elif len(include_parts) == 2 and include_parts[1] is not None:
        from_, to_ = include_parts

    include_path = Path(current_project.source, from_)
    if not include_path.exists():
        panic(f"Cannot find include path '{include_path}'.")
    if include_path.is_dir():
        if to_ == ".":
            # We cannot just copytree, or an "already-existing" error will be raised. Instead, we will copy everything from the target directory to the build directory.
            for item in os.listdir(include_path):
                item_path = Path(include_path, item)
                dest_path = Path(project_build_dir, item)
                if item_path.is_dir():
                    shutil.copytree(item_path, dest_path)
                else:
                    shutil.copy2(item_path, dest_path)
        else:
            shutil.copytree(include_path, Path(project_build_dir, to_))
    else:
        if to_ == ".":
            panic(f"Include destination of '.' is not allowed for files.")
        shutil.copy2(include_path, Path(project_build_dir, to_))

YELETS_DEFINES = {
    "build_info": yelets_build_info,
    "call": yelets_call,
    "build_include": yelets_build_include,
}

def build(args):
    global build_version
    build_version = args.build_version
    global build_debug
    build_debug = args.build_debug 

    print(f"Start build process:\n{INDENTATION}Directory: {cwd}\n{INDENTATION}Version:   {build_version}\n{INDENTATION}Debug:     {build_debug}")

    build_dir.mkdir(parents=True, exist_ok=True)

    # Collect projects.
    for source, subdirs, subfiles in cwd.walk():
        for file in subfiles:
            # @todo We should be able to search for `project`, `project.y`, `project.jai`, etc. Project file implementation does not matter as long as we have driver for it. What matters, is complying to our standards - drivers should execute file in a way, that left us with a namespace map, with converted to python objects, including functions.
            if file == "project":
                config_path = Path(source, file)
                # We must have a name, or we consider project.cfg not matching our ideology.
                project_context = yelets.execute_file(config_path, YELETS_DEFINES)
                project_name = project_context.get("name", "")
                if not isinstance(project_name, str):
                    print(f"Invalid project name at location '{config_path}'.")
                    continue
                elif project_name == "":
                    print(f"Empty project name at location '{config_path}'.")
                    continue
                elif project_name is None or project_name == "":
                    print(f"Skip invalid project configuration at '{config_path}'.")
                    continue

                project = Project(
                    source=source,
                    name=project_name,
                    context=project_context,
                )
                projects[project.name] = project

    print(f"Collected {len(projects)} projects.")
    print()

    # We remove the whole dir "build" - noone else should occupy it if we're about to use project utilities at full capacity.
    # Do it at this stage to remove after the projects are collected.
    shutil.rmtree(build_dir)
    global build_time
    build_time = int(time.time() * 1000)

    for i, project in enumerate(projects.values()):
        if i != 0:
            # Separate entries.
            print()

        print(f"== BUILD: {project.name} ==")
        build_function = project.context.get("build", None)
        if build_function is None or not callable(build_function):
            print(f"{colorama.Fore.WHITE}{colorama.Style.DIM}No build procedure.{colorama.Fore.RESET}{colorama.Style.RESET_ALL}")
            continue
        global current_project
        current_project = project
        # @todo Pass some context to custom build functions.
        build_function()


if __name__ == "__main__":
    main()
