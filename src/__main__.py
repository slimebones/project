# Project management tool.

import argparse
from os import PathLike
import datetime
from src import yelets
import os
import multiprocessing
from pathlib import Path
import re
import shutil
import subprocess
import sys
import threading
import time
from typing import Callable, Literal
from pydantic import BaseModel as struct
import configparser

VERSION = 0

INDENTATION = " " * 4

RED = '\033[31m'
GREEN = '\033[32m'
RESET = '\033[0m'
GREY = '\033[90m'
# ]]]] nvim fix

# Project is always called in the current working directory. @todo add ability to override cwd via CLI.
cwd = Path.cwd()
build_dir = Path(cwd, "build")

class Project(struct):
    source: Path
    name: str
    context: str

projects: dict[str, Project] = {}

def call(command: str, location: str | Path = Path.cwd(), callback: Callable[[int, str], None] | None = None) -> int:
    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=location,
        bufsize=1,
        universal_newlines=True,
    )
    # @todo Make it parallel, somehow. For now it is printed only at the end of the subprocess. At least this behaviour is noticed at Windows.
    if callback is not None:
        if process.stdout is not None:
            for line in process.stdout:
                callback(1, line)
        if process.stderr is not None:
            for line in process.stderr:
                callback(2, line)
    return process.wait()

def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title="Commands", dest="command")

    build_parser = subparsers.add_parser("build", help="Build tool.")
    build_parser.add_argument("build_version", type=int)
    build_parser.add_argument("-debug", action="store_true", dest="build_debug")

    args = parser.parse_args()

    if args.command == "build":
        build(args)
    else:
        parser.print_help()

def yelets_build_info(target: PathLike):
    print(f"Generate build info to '{target}'.")
    extension = target.suffix.removeprefix(".")
    auto_message = "AUTO-GENERATED BY THE BUILD SYSTEM. DO NOT EDIT!"
    content = ""
    if extension == "py":
        content = f"# {auto_message}\nBUILD_VERSION = {build_version}\nBUILD_TIME = {build_time}\nBUILD_DEBUG = {'True' if build_debug else 'False'}"
    elif extension == "js":
        BRACKET_LEFT = "{"
        BRACKET_RIGHT = "}"
        content = f"// {auto_message}\nconst BUILD_VERSION = {build_version};\nconst BUILD_TIME = {build_time};\nconst BUILD_DEBUG = {'true' if build_debug else 'false'};\nexport {BRACKET_LEFT} BUILD_VERSION, BUILD_TIME, BUILD_DEBUG {BRACKET_RIGHT};\n"
    else:
        panic(f"Unsupported build info extension '{extension}' at location '{config_path}'.")
    with target.open("w+") as f:
        f.write(content)

def panic(message: str):
    raise Exception("PANIC: " + message)

def yelets_build_include(target: PathLike, dest: PathLike | None = None):
    print(f"build: Include target '{target}'." + f"Destination is altered to '{dest}'." if dest else "") 
    project_build_dir = Path(build_dir, project.name)
    # Such project dir shouldn't exist since we should have cleared build directory.
    project_build_dir.mkdir(parents=True, exist_ok=False)

    if include == "":
        continue

    include_parts = (target, dest)
    from_ = include
    to_ = include
    if ".." in include:
        panic(f"The '..' paths found in include '{include}'.")
    elif len(include_parts) > 2:
        panic(f"Incorrect include schematics '{include}'.")
    elif len(include_parts) == 2:
        from_, to_ = include_parts

    include_path = Path(project.source, from_)
    if not include_path.exists():
        panic(f"Cannot find include path '{include_path}'.")
    if include_path.is_dir():
        if to_ == ".":
            # We cannot just copytree, or an "already-existing" error will be raised. Instead, we will copy everything from the target directory to the build directory.
            for item in os.listdir(include_path):
                item_path = Path(include_path, item)
                dest_path = Path(project_build_dir, item)
                if item_path.is_dir():
                    shutil.copytree(item_path, dest_path)
                else:
                    shutil.copy2(item_path, dest_path)
        else:
            shutil.copytree(include_path, Path(project_build_dir, to_))
    else:
        if to_ == ".":
            panic(f"Include destination of '.' is not allowed for files.")
            error = True
            break
        shutil.copy2(include_path, Path(project_build_dir, to_))

YELETS_DEFINES = {
    "build_info": yelets_build_info,
    "call": call,
    "build_include": yelets_build_include,
}

def build(args):
    build_version: int = args.build_version
    build_debug: bool = args.build_debug 

    print(f"Start build process:\n{INDENTATION}Version: {build_version}\n{INDENTATION}Debug:   {build_debug}")

    build_dir.mkdir(parents=True, exist_ok=True)

    # Collect projects.
    for source, subdirs, subfiles in cwd.walk():
        for file in subfiles:
            if file == "project":
                config_path = Path(source, file)
                # We must have a name, or we consider project.cfg not matching our ideology.
                project_context = yelets.execute_file(config_path, YELETS_DEFINES)
                project_name = project_context.get("name", "")
                if not isinstance(project_name, str):
                    print(f"Invalid project name at location '{config_path}'.")
                    print("Exit with code 1.")
                    exit(1)
                elif project_name == "":
                    print(f"Empty project name at location '{config_path}'.")
                    print("Exit with code 1.")
                    exit(1)
                elif not re.match(r"^[a-z_][a-z0-9_]*$", project_name):
                    print(f"Invalid project name '{project_name}' at location '{config_path}'. Must be in format of snake_case, not starting with digit.")
                    print("Exit with code 1.")
                    exit(1)
                elif project_name is None or project_name == "":
                    print(f"Skip invalid project configuration at '{config_path}'.")
                    continue

                build_info = config.get("build", "info", fallback="").strip("\"")
                if build_info:
                    build_info = Path(source, build_info)
                    if build_info.exists() and build_info.is_dir():
                        print(f"Build info path '{build_info}' at location '{config_path}' must be a file.")
                        print("Exit with code 1.")
                        exit(1)
                else:
                    build_info = None

                project = Project(
                    source=source,
                    name=project_name,
                    build_context=build_context,
                )
                projects[project.name] = project

    print(f"Collected {len(projects)} projects.")
    print()

    # We remove the whole dir "build" - noone else should occupy it if we're about to use project utilities at full capacity.
    # Do it at this stage to remove after the projects are collected.
    shutil.rmtree(build_dir)
    build_time = int(time.time() * 1000)

    for i, project in enumerate(projects.values()):
        if i != 0:
            # Separate entries.
            print("")

        print(f"== BUILD: {project.name} ==")


if __name__ == "__main__":
    main()
