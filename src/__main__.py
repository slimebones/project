# Project management tool.

import argparse
from typing import Any
from os import PathLike
import colorama
import datetime
from src import yelets
import os
import multiprocessing
from pathlib import Path
import re
import shutil
import subprocess
import sys
import threading
import time
from typing import Callable, Literal
from pydantic import BaseModel as struct
import configparser


VERSION = 0

INDENTATION = " " * 4

RED = '\033[31m'
GREEN = '\033[32m'
RESET = '\033[0m'
GREY = '\033[90m'
# ]]]] nvim fix

# Project is always called in the current working directory. @todo add ability to override cwd via CLI.
cwd = Path.cwd()
build_dir: Path
build_version = 0
build_time = 0
build_debug = False

class Project(struct):
    source: Path
    name: str
    context: dict[str, Any]

current_project: Project
projects: dict[str, Project] = {}

def yelets_call(command: str, callback: Callable[[int, str], None] | None = None):
    # Always call relatively to current project.
    location = current_project.source

    # Use nushell command.
    if "\"" in command:
        print(f"{colorama.Fore.YELLOW}WARNING{colorama.Fore.RESET}: Please, do not use double-quotes for 'call' commands - they will be replaced with single-quotes. Occurred for project '{current_project.name}', command: {command}")
        command = command.replace("\"", "'")
    command = f"nu -c \"{command}\""

    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=location,
        bufsize=1,
        universal_newlines=True,
    )
    # @todo Make it parallel, somehow. For now it is printed only at the end of the subprocess. At least this behaviour is noticed at Windows.
    if callback is not None:
        if process.stdout is not None:
            for line in process.stdout:
                callback(1, line)
        if process.stderr is not None:
            for line in process.stderr:
                callback(2, line)
    code = process.wait()
    if code != 0:
        panic(f"Call returned code {code}, location '{location}', command: {command}")

def yelets_build_info(target: PathLike):
    print(f"Generate build info to '{target}'.")
    target = Path(current_project.source, target)
    extension = target.suffix.removeprefix(".")
    auto_message = "AUTO-GENERATED BY THE BUILD SYSTEM. DO NOT EDIT!"
    content = ""
    if extension == "py":
        content = f"# {auto_message}\nBUILD_VERSION = {build_version}\nBUILD_TIME = {build_time}\nBUILD_DEBUG = {'True' if build_debug else 'False'}"
    elif extension == "js":
        BRACKET_LEFT = "{"
        BRACKET_RIGHT = "}"
        content = f"// {auto_message}\nconst BUILD_VERSION = {build_version};\nconst BUILD_TIME = {build_time};\nconst BUILD_DEBUG = {'true' if build_debug else 'false'};\nexport {BRACKET_LEFT} BUILD_VERSION, BUILD_TIME, BUILD_DEBUG {BRACKET_RIGHT};\n"
    else:
        panic(f"Unsupported build info extension '{extension}' at location '{config_path}'.")
    with target.open("w+") as f:
        f.write(content)

def panic(message: str):
    raise Exception("PANIC: " + message)

def yelets_build_include(target: PathLike, dest: PathLike | None = None):
    target = Path(target)
    real_target = Path(current_project.source, target)

    message = f"Include target '{target}'."
    if dest:
        message += f" Destination is altered to '{dest}'."
    print(message) 

    project_build_dir = Path(build_dir, current_project.name)
    project_build_dir.mkdir(parents=True, exist_ok=True)

    if not real_target.exists():
        panic(f"Cannot find include path '{real_target}'.")
    elif real_target.is_dir():
        if dest == ".":
            # We cannot just copytree, or an "already-existing" error will be raised. Instead, we will copy everything from the target directory to the build directory.
            for item in os.listdir(real_target):
                item_path = Path(real_target, item)
                dest_path = Path(project_build_dir, item)
                if item_path.is_dir():
                    shutil.copytree(item_path, dest_path)
                else:
                    shutil.copy2(item_path, dest_path)
        else:
            shutil.copytree(real_target, Path(project_build_dir, dest if dest else target))
    else:
        if dest == ".":
            panic(f"Include destination of '.' is not allowed for files.")
        shutil.copy2(real_target, Path(project_build_dir, dest if dest else target))

YELETS_DEFINES = {
    "build_info": yelets_build_info,
    "call": yelets_call,
    "build_include": yelets_build_include,
    "panic": panic,
}

def build(args):
    global build_version
    build_version = args.build_version
    global build_debug
    build_debug = args.build_debug 

    message = """Start build process:
{ind}Root Directory:        {cwd}
{ind}Build Directory:       {build_dir}
{ind}Chosen Version:        {build_version}
{ind}Debug:                 {build_debug}
""".format(ind=INDENTATION, cwd=cwd, build_version=build_version, build_debug=build_debug, build_dir=build_dir)
    print(message)

    build_dir.mkdir(parents=True, exist_ok=True)

    # Collect projects.
    for source, subdirs, subfiles in cwd.walk():
        for file in subfiles:
            # @todo We should be able to search for `project`, `project.y`, `project.jai`, etc. Project file implementation does not matter as long as we have driver for it. What matters, is complying to our standards - drivers should execute file in a way, that left us with a namespace map, with converted to python objects, including functions.
            if file == "project":
                config_path = Path(source, file)
                # We must have a name, or we consider project.cfg not matching our ideology.
                project_context = yelets.execute_file(config_path, YELETS_DEFINES)
                project_name = project_context.get("name", "")
                if not isinstance(project_name, str):
                    print(f"Invalid project name at location '{config_path}'.")
                    continue
                elif project_name == "":
                    print(f"Empty project name at location '{config_path}'.")
                    continue
                elif project_name is None or project_name == "":
                    print(f"Skip invalid project configuration at '{config_path}'.")
                    continue

                project = Project(
                    source=source,
                    name=project_name,
                    context=project_context,
                )
                projects[project.name] = project

    print(f"Collected {len(projects)} projects.")
    print()

    # We remove the whole dir "build" - noone else should occupy it if we're about to use project utilities at full capacity.
    # Do it at this stage to remove after the projects are collected.
    shutil.rmtree(build_dir)
    global build_time
    build_time = int(time.time() * 1000)

    for i, project in enumerate(projects.values()):
        if i != 0:
            # Separate entries.
            print()

        print(f"{colorama.Fore.MAGENTA}== BUILD: {project.name} =={colorama.Fore.RESET}")
        print(colorama.Style.DIM, end="")
        build_function = project.context.get("build", None)
        if build_function is None or not callable(build_function):
            print(f"{colorama.Fore.WHITE}{colorama.Style.DIM}No build procedure.{colorama.Fore.RESET}{colorama.Style.RESET_ALL}")
            continue
        global current_project
        current_project = project
        try:
            # @todo Pass some context to custom build functions.
            build_function()
        except Exception as error:
            print(f"{colorama.Fore.RED}ERROR{colorama.Fore.RESET}: Build function of project '{project.name}' panicked with an error: {error}")
            print(f"{colorama.Fore.RED}Build for '{project.name}' failed.{colorama.Fore.RESET}")
        else:
            print(f"{colorama.Fore.GREEN}Build for '{project.name}' finished.{colorama.Fore.RESET}")
        print(colorama.Style.RESET_ALL, end="")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-cwd", type=Path, dest="cwd", default=Path.cwd())
    subparsers = parser.add_subparsers(title="Commands", dest="command")

    build_parser = subparsers.add_parser("build", help="Build tool.")
    build_parser.add_argument("build_version", type=int)
    build_parser.add_argument("-debug", action="store_true", dest="build_debug")

    args = parser.parse_args()
    global cwd
    cwd = args.cwd
    global build_dir
    build_dir = Path(cwd, "build")

    if args.command == "build":
        build(args)


if __name__ == "__main__":
    main()
