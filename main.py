# Project management tool.

import argparse
from typing import Any
from os import PathLike
import colorama
import location
import yelets
import os
from pathlib import Path
import re
import shutil
import subprocess
import time
from typing import Callable, Literal
from pydantic import BaseModel


class Project(BaseModel):
    source: Path
    name: str
    context: dict[str, Any]


indentation = " " * 4
codename_rules = """{ind}1. alphanumeric
{ind}2. lower case
{ind}3. separated by underscores
{ind}4. not starting with an underscore
{ind}5. not ending with an underscore
{ind}6. not starting with a digit"""

red = '\033[31m'
green = '\033[32m'
reset = '\033[0m'
grey = '\033[90m'
# ]]]] nvim fix

# Project is always called in the current working directory. @todo add ability to override cwd via CLI.
cwd = location.cwd()
build_dir: Path
project_codes: list[str] = []

current_project: Project
projects: dict[str, Project] = {}


# @legacy this call is custom, when it's available, recommend to use Yelet's `std.call()`
def yelets_call(command: str, callback: Callable[[int, str], None] | None = None):
    # Always call relatively to the current project.
    loc = current_project.source

    # Use nushell command.
    if "\"" in command:
        print(f"{colorama.Fore.YELLOW}WARNING{colorama.Fore.RESET}: Please, do not use double-quotes for 'call' commands - they will be replaced with single-quotes. Occurred for project '{current_project.name}', command: {command}")
        command = command.replace("\"", "'")
    command = f"nu -c \"{command}\""

    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=loc,
        bufsize=1,
        universal_newlines=True,
    )
    # @todo Make it parallel, somehow. For now it is printed only at the end of the subprocess. At least this behaviour is noticed at Windows.
    if callback is not None:
        if process.stdout is not None:
            for line in process.stdout:
                callback(1, line)
        if process.stderr is not None:
            for line in process.stderr:
                callback(2, line)
    code = process.wait()
    if code != 0:
        raise Exception(f"Call returned code {code}, location '{loc}', command: {command}")


# Build a codesheet, writing to given `target`.
#
# Built codesheet includes a programming-language-specific compile-time (or boot-time) constant definitions, and a dictionary-like definition, where the keys are codes, and the values are codenames.
def yelets_buildCodes(target: PathLike):
    print(f"Generate codes to '{target}'.")
    target = Path(current_project.source, target)
    extension = target.suffix.removeprefix(".")
    content = ""
    codenames = ""
    # Codes must be already valid at this point.
    if extension == "py":
        content += "OK = 0\n"
        for code, codename in enumerate(project_codes):
            code += 1
            content += f"{codename} = {code}\n"
            codenames += f"{indentation}{code}: \"{codename}\",\n"

        content += """
codenames: dict[int, str] = {{
{codenames}}}""".format(codenames=codenames)

    elif extension in ["js", "ts"]:
        content += "export const OK = 0;\n"
        for code, codename in enumerate(project_codes):
            code += 1
            content += f"export const {codename} = {code};\n"
            codenames += f"{indentation}{code}: \"{codename}\",\n"

        content += """
export const codenames = {{
{codenames}}};""".format(codenames=codenames)

    else:
        raise Exception(f"Unsupported codes extension '{extension}' at location '{target}'.")
    with target.open("w+") as f:
        f.write(content)


def yelets_buildInfo(target: PathLike):
    print(f"Generate build info to '{target}'.")
    target = Path(current_project.source, target)
    extension = target.suffix.removeprefix(".")
    auto_message = "AUTO-GENERATED BY THE BUILD SYSTEM. DO NOT EDIT!"
    content = ""
    if extension == "py":
        content = f"# {auto_message}\nBUILD_VERSION = \"{build_version}\"\nBUILD_TIME = {build_time}\nBUILD_DEBUG = {'True' if build_debug else 'False'}"
    elif extension in ["js", "ts"]:
        BRACKET_LEFT = "{"
        BRACKET_RIGHT = "}"
        content = f"// {auto_message}\nconst BUILD_VERSION = \"{build_version}\";\nconst BUILD_TIME = {build_time};\nconst BUILD_DEBUG = {'true' if build_debug else 'false'};\nexport {BRACKET_LEFT} BUILD_VERSION, BUILD_TIME, BUILD_DEBUG {BRACKET_RIGHT};\n"
    else:
        raise Exception(f"Unsupported build info extension '{extension}' at location '{target}'.")
    with target.open("w+") as f:
        f.write(content)


def yelets_buildInclude(target: PathLike, dest: PathLike | None = None):
    target = Path(target)
    real_target = Path(current_project.source, target)

    message = f"Include target '{target}'."
    if dest:
        message += f" Destination is altered to '{dest}'."
    print(message)

    project_build_dir = Path(build_dir, current_project.name)
    project_build_dir.mkdir(parents=True, exist_ok=True)

    if not real_target.exists():
        raise Exception(f"Cannot find include path '{real_target}'.")
    elif real_target.is_dir():
        if dest == ".":
            # We cannot just copytree, or an "already-existing" error will be raised. Instead, we will copy everything from the target directory to the build directory.
            for item in os.listdir(real_target):
                item_path = Path(real_target, item)
                dest_path = Path(project_build_dir, item)
                if item_path.is_dir():
                    shutil.copytree(item_path, dest_path)
                else:
                    shutil.copy2(item_path, dest_path)
        else:
            shutil.copytree(real_target, Path(project_build_dir, dest if dest else target))
    else:
        if dest == ".":
            raise Exception(f"Include destination of '.' is not allowed for files.")
        shutil.copy2(real_target, Path(project_build_dir, dest if dest else target))

def build(args):
    global build_version_major
    global build_version_minor
    global build_version_patch
    major, minor, patch = args.build_version.removeprefix("v").split(".")
    build_version_major = int(major)
    build_version_minor = int(minor)
    build_version_patch = int(patch)
    if build_version_major < 0 or build_version_minor < 0 or build_version_patch < 0:
        raise Exception("Wrong version setup.")
    global build_version
    build_version = f"v{build_version_major}.{build_version_minor}.{build_version_patch}"

    global build_debug
    build_debug = args.build_debug

    message = """Start build process:
{ind}Root Directory:        {cwd}
{ind}Build Directory:       {build_dir}
{ind}Chosen Version:        {build_version}
{ind}Debug:                 {build_debug}
""".format(ind=indentation, cwd=cwd, build_version=build_version, build_debug=build_debug, build_dir=build_dir)
    print(message)

    build_dir.mkdir(parents=True, exist_ok=True)

    # Collect projects.
    for source, subdirs, subfiles in cwd.walk():
        for file in subfiles:
            # @todo We should be able to search for `project`, `project.y`, `project.jai`, etc. Project file implementation does not matter as long as we have a driver for it. What matters, is complying to our standards - drivers should execute file in a way, that left us with a namespace map, with converted to python objects, including functions.
            if file == "project":
                config_path = Path(source, file)
                # We must have a name, or we consider project.cfg not matching our ideology.

                yelets_defines = {
                    "buildInfo": yelets_buildInfo,
                    "call": yelets_call,
                    "buildInclude": yelets_buildInclude,
                    "buildCodes": yelets_buildCodes,
                }
                project_context = yelets.execute_file(config_path, yelets_defines)
                project_name = project_context.get("name", "")
                if not isinstance(project_name, str):
                    print(f"Invalid project name at location '{config_path}'.")
                    continue
                elif project_name == "":
                    print(f"Empty project name at location '{config_path}'.")
                    continue
                elif project_name is None or project_name == "":
                    print(f"Skip invalid project configuration at '{config_path}'.")
                    continue

                project = Project(
                    source=source,
                    name=project_name,
                    context=project_context,
                )
                projects[project.name] = project

    print(f"Collected {len(projects)} projects.", end="\n\n")

    # We remove the whole dir "build" - noone else should occupy it if we're about to use project utilities at full capacity.
    # Do it at this stage to remove after the projects are collected.
    shutil.rmtree(build_dir)
    global build_time
    build_time = int(time.time() * 1000)

    for i, project in enumerate(projects.values()):
        if i != 0:
            # Separate entries.
            print()

        print(f"{colorama.Fore.MAGENTA}== BUILD: {project.name} =={colorama.Fore.RESET}")
        print(colorama.Style.DIM, end="")
        build_function = project.context.get("build", None)
        if build_function is None or not callable(build_function):
            print(f"{colorama.Fore.WHITE}{colorama.Style.DIM}No build procedure.{colorama.Fore.RESET}{colorama.Style.RESET_ALL}")
            continue
        global current_project
        current_project = project
        try:
            # @todo Pass some context to custom build functions.
            build_function()
        except Exception as error:
            print(f"{colorama.Fore.RED}ERROR{colorama.Fore.RESET}: Build function of project '{project.name}' panicked with an error: {error}")
            print(f"{colorama.Fore.RED}Build for '{project.name}' failed.{colorama.Fore.RESET}")
        else:
            print(f"{colorama.Fore.GREEN}Build for '{project.name}' finished.{colorama.Fore.RESET}")
        print(colorama.Style.RESET_ALL, end="")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-cwd", type=Path, dest="cwd", default=Path.cwd())

    subparsers = parser.add_subparsers(title="Commands", dest="command")

    # `project build`
    build_parser = subparsers.add_parser("build", help="Build tool.")
    build_parser.add_argument("version", type=str)
    build_parser.add_argument("-debug", action="store_true", dest="build_debug")

    args = parser.parse_args()
    global cwd
    cwd = args.cwd
    global build_dir
    build_dir = Path(cwd, "build")

    with Path(cwd, "codes.txt").open("r") as file:
        lines = file.readlines()
        for line in lines:
            line = line.strip().lower()
            # Codes must be parsed strictly. We want our `codes.txt` file to look clean.
            # We add even empty lines - codes must be correctly enumerated. Later empty lines will be replaced by empty lines during code-file generation.
            if line:
                if line in ["ok", "codenames"]:
                    raise Exception(f"Cannot use reserved codename '{line}'.")
                if not re.match(r"^(?![0-9])(?<!_)([a-z0-9]+(?:_[a-z0-9]+)*)[^_]$", line):
                    raise Exception(f"Invalid codename: '{line}'. Codename rules:\n{codename_rules.format(ind=indentation)}")
                if line in project_codes:
                    raise Exception(f"Duplicate definition of a codename '{line}'.")

            project_codes.append(line)

    print(f"Collected {len(project_codes)} project codes.", end="\n\n")

    match args.command:
        case "build":
            build(args)
        case _:
            raise Exception(f"unrecognized command '{args.command}'")


if __name__ == "__main__":
    main()
